# -*- coding: utf-8 -*-
"""
This module is a set of tools for setting up and working with the program DDScat.




"""

from __future__ import division
import pdb
import subprocess
import numpy as np
import os
import os.path
import copy
import time
import math
import glob
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from collections import OrderedDict
#import scipy.interpolate
#import matplotlib.pyplot as plt
#import warnings

#The DDScat executable
#landau executable
ddscat_path='/opt/local/lib/ddscat/src'
#local executable
#ddscat_path='ddscat'

#The default materials library location
#landau
mat_library='/home/guests/mark/mat_prop'
#local
#mat_library='~/Documents/Analysis/ddscat/mp/'




class How_Range():
    """
    A general range used for wavelength and aeff definitions.
    
    The range can be used as an iterator.    
    
    """
    def __init__(self, first, last, num, how=None, table=None):
        """
        Initialize the range
        
        Arguments:
            first: the first value of the range
            last: the last value of the range
            num: the number of steps in the range
            how: an optional string defining the spacing of steps 'LIN', 'INV', 'LOG', 'TAB'
                 default is 'LIN'
            table: an optional list of table values that specify an arbitrary sequence
        
        """
        self.first=first
        self.last=last
        self.num=num
        self.how=how if how is not None else 'LIN'
        
        if self.how=='TAB':
            if self.tab is None:
                raise ValueError('TAB range requires table of values')
        self.build_table()

    def __str__(self):
        return '%f  %f  %d  %s'%(self.first, self.last, self.num, self.how)
   
    def build_table(self):
        if self.how=='LIN':
            self.table=np.linspace(self.first, self.last, self.num)
        if self.how=='INV':
            l=self.table=np.linspace(1/self.first, 1/self.last, self.num)
            self.table=1/l
        if self.how=='LOG':
            self.table=np.logspace(np.log10(self.first), np.log10(self.last), self.num)

    def __iter__(self):
        self.build_table()
        self.current=0
        return self
    
    def next(self):
        if self.current==len(self.table):
            raise StopIteration
        
        self.current+=1
        return self.table[self.current-1]

    

class Lin_Range(How_Range):
    """
    A specialized linear range used for specifying target rotations.
    
    The range can be used as an iterator.    
    
    """
    def __init__(self, first, last, num):
        """
        Initialize the range
        
        Arguments:
            first: the first value of the range
            last: the last value of the range
            num: the number of steps in the range
        """
        How_Range.__init__(self, first, last, num, 'LIN')

    def __str__(self):
        return '%f  %f  %d'%(self.first, self.last, self.num)

     
class Scat_Range():
    '''
    A specialist range used for specifying scattering planes.

    Does not yet include an iterator    
    '''
    def __init__(self, phi, theta_min, theta_max, dtheta):
        """
        Initialize the range
        
        Arguments:
            phi: the phi scattering angle
            theta_min: the smallest value of theta
            theta_max: the largest value of theta
            d_theta: the theta stepsize
        """

        self.phi=phi
        self.theta_min=theta_min
        self.theta_max=theta_max
        self.dtheta=dtheta

    def __str__(self):
        return '%f  %f  %f  %s'%(self.phi, self.theta_min, self.theta_max, self.dtheta)



class Settings():
    '''
    A class for specifying DDScat execution parameters
    
    Most of the field names correspond to their definitions in the ddscat.par file.
    
    '''

    def __init__(self, **kwargs):        
        self.CMDTRQ= False #NOTORQ = 'CMDTRQ'*6 (NOTORQ, DOTORQ) -- either do or skip torque calculations
        self.CMDSOL='PBCGS2'# = CMDSOL*6 (PBCGS2, PBCGST, GPBICG, PETRKP, QMRCCG) -- solution method
        self.CMDFFT='GPFAFT'# = CMDFFT*6 (GPFAFT, FFTMKL) -- FFT method
        self.CALPHA='GKDLDR'# = CALPHA*6 (GKDLDR, LATTDR) -- prescription for polarizabilities
        self.CBINFLAG='NOTBIN'# = CBINFLAG (NOTBIN, ORIBIN, ALLBIN) -- specify binary output

        self.InitialMalloc=np.array([100,100,100])

        self.NRFLD=False #0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
        self.NRFLD_EXT=np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])# (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)

        self.TOL=1.00e-5# = TOL = MAX ALLOWED (NORM OF |G>=AC|E>-ACA|X>)/(NORM OF AC|E>)
        self.MXITER=600
        self.GAMMA=1.00e-2# = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)

        self.ETASCA=0.5#	= ETASCA (number of angles is proportional to [(3+x)/ETASCA]^2 )
        self.IWRKSC=True#1 = IWRKSC (=0 to suppress, =1 to write ".sca" file for each target orient.
        self.wavelengths=How_Range(0.3500, 0.8000, 10, 'LIN')# = wavelengths (first,last,how many,how=LIN,INV,LOG)

        self.NAMBIENT=1.000# = NAMBIENT
        self.scale_range=None #define a range of scales for the particle geometry, None indicates a single size calc

        self.Epol=np.array([0+0j, 1.+0j, 0.+0j]) #= Polarization state e01 (k along x axis)
        self.IORTH=2 #  (=1 to do only pol. state e01; =2 to also do orth. pol. state)

        self.beta=Lin_Range(0.,0.,1) #  = BETAMI, BETAMX, NBETA  (beta=rotation around a1)
        self.theta=Lin_Range(0.,0.,1)#= THETMI, THETMX, NTHETA (theta=angle between a1 and k)
        self.phi=Lin_Range(0.,0.,1)#  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
        '**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****'
        self.first_I=[0,   0,   0]#    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
        '**** Select Elements of S_ij Matrix to Print ****'
        #self.NSMELTS=6#	= NSMELTS = number of elements of S_ij to print (not more than 9)
        self.S_INDICES=[11, 12, 13, 14, 21, 22, 31, 41, 44]#	= indices ij of elements to print
        '**** Specify Scattered Directions ****'
        self.CMDFRM='LFRAME'# = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
        self.scat_planes=[Scat_Range(0,0,180,5), Scat_Range(90,0,180,5)]

        #***** Specify if calculation is to be run with serial or parallel code on landau
        self.serial=True
        #self.NPLANES=2# = NPLANES = number of scattering planes
        #0.   0. 180.  5 = phi, thetan_min, thetan_max, dtheta (in deg) for plane 1
        #90.  0. 180.  5 = phi, thetan_min, thetan_max, dtheta (in deg) for plane 2


        

class DDscat():
    """
    A class for managing a DDscat run.
    
    Loosely a DDscat object includes three parts: a settings file and a target
    
    Example:
    #Build a target
    t=Target_CYLNDRCAP(0.100, 0.030):        
        
    #Initialize a DDscat run
    d=DDscat(target=t)
    
    #Modify run parameters as desired
    d.settings.NAMBIEND=1.5
    d.settings.Epol=np.array([0, 1j, 1])

    #Write the output and run the simulation
    d.run()

    #Load the results
    d.results.refresh()
    
    #Plot them
    d.results.qtable.plot()
    """

    def __init__(self, folder=None, target=None):
        """
        Initialize the class.
        
        Arguments:
            folder: is the folder where the ddscat.par file will be stored (default is CWD)
                    A folder that does not yet exist will be created
            target: optional target to use. Default is to create 200nm sphere.
        """        
        
        if folder is None:
            self.folder='./'
        else:
            if not os.path.exists(folder):
                os.makedirs(folder)
            self.folder=folder        
        self.settings=Settings(folder=self.folder)
        
        if target is None:
            self.target=Target_Sphere(0.2, folder=self.folder)
        else:
            self.target=target
            self.target.folder=self.folder
            
        self.results=Results(folder=self.folder)
        
    def __str__(self):
        return 'DDScat Definition'

    def refresh(self):
        """Refresh the results from disk."""
        self.results.refresh()

    def write(self, write_sge=False):
        """Write the .par file and target definition to file
        
        Arguments:
            write_sge: Use True to write a .sge file for submitting the job on the cluster via qsub
        
        """

        s=build_ddscat_par(self.settings, self.target)
        
        with open(os.path.join(self.folder, 'ddscat.par'), 'wt') as f:
            f.write(s)

        self.target.folder=self.folder
        self.target.write()

        if write_sge:
            with open(os.path.join(self.folder, 'submit.sge'), 'wt') as f:

                f.write('#!/bin/csh\n' )
                f.write('#\n#\n#\n')
                f.write('# ---------------------------\n')
                f.write('# our name \n')
                
                if self.settings.serial:
                    f.write('#$ -N ddscat_ser\n')
                else:
                    f.write('#$ -N ddscat_mpi\n')
                    f.write('# pe request\n')
                    f.write('#$ -pe openmpi 4-16\n')

                f.write('#\n')
                f.write('# stderr >& stdout\n')
                f.write('#$ -j y\n')
                f.write('#\n')
                f.write('# ---------------------------\n')
                
                
                f.write('set hostname=`/bin/hostname`\n')

                f.write('echo beginning `pwd`\n')
                f.write('date\n')
                if self.settings.serial:
                    f.write('time /cluster/bin/ddscat\n')
                else:
                    f.write('time /usr/mpi/gcc/openmpi-1.4.2/bin/mpirun -np $NSLOTS /cluster/bin/ddscat_openmpi\n')
                f.write('echo completed `pwd`\n')
                f.write('echo \'------------------------------------------\'\n')
                f.write('date\n')

#    def batch_str(self):
#        
#        folder=os.path.join('~', os.path.normpath(self.folder))
#        return 'qsub -wd %s %s \n' % (folder, os.path.join(folder, 'submit.sge'))


    def set_folder(self, newfolder):
        """Redefine the run's home folder."""
        if not os.path.exists(newfolder):
            os.makedirs(newfolder)
      
        self.folder=newfolder
        self.target.set_folder(newfolder)
        self.results.set_folder(newfolder)

    def set_target(self, newtarget):
        """Redefine the run's target."""
        self.target=newtarget
        self.target.set_folder(self.folder)

    def info(self):
        """Print some basic run info"""
        wave=self.settings.wavelengths.table
        N=self.target.N
        
        alpha=self.alpha()
        beta=self.beta()
        x=self.x()
        table=np.vstack([wave, x, alpha, beta])
        print "Target: "+self.target.directive
        print 'Shape: ' + str(self.target.shape)
        print 'N=%d'%N
        print 'aeff=%f'%self.target.aeff()
        print 'd=%f'%self.target.d

        print 'wave\tx\talpha\tbeta'
        print '-----------------------------------'
        for r in table.transpose():
            print r

    def x(self):
        """Calculate the x-parameter (Userguide p8)."""
        a=self.target.aeff()
        out=[]        
        for l in self.settings.wavelengths:
            out.append(2*np.pi*a/l)

        return np.asarray(out)
        
    def mkd(self):
        """Calculate m*k*d (Userguide p8)."""
        m_dat=MInTable(self.target.mat_file)
        out=[]
        for l in self.settings.wavelengths:
            m=m_dat(l)
            out.append(m*2*np.pi/l*self.target.d)
            
        return np.asarray(out)
    
    def alpha(self):
        """Calculate the alpha parameter (Userguide Eqn 8, p8)."""
        N=self.target.N
        m_dat=MInTable(self.target.mat_file)
        out=[]
        for l in self.settings.wavelengths:
            m=m_dat(l)
            out.append(9.88*l/np.abs(m['Rem']+1j*m['Imm'])*(N/10**6)**(1/3))

        return np.asarray(out)

    def beta(self):
        """Calculateth beta parameter (Userguide Eqn 8, p8)."""
        N=self.target.N
        m_dat=MInTable(self.target.mat_file)
        out=[]
        for l in self.settings.wavelengths:
            m=m_dat(l)
            out.append(62/np.abs(m['Rem']+1j*m['Imm'])*(N/10**6)**(1/3))

        return np.asarray(out)
            

    def calculate(self, silent=False):
        """Start local calculation of this run.
        
        Arguments:
            silent: If true suppresses output to the screen
        """

        self.write()

        command=os.path.join(ddscat_path, 'ddscat')
        if silent:
            print 'Starting calculation...'
            subprocess.call(command+' 2> output.log', shell=True, cwd=self.folder)
            print 'Done!'
        else:
            subprocess.call(command + ' 2>&1 | tee output.log', shell=True, cwd=self.folder)
        
        self.results.refresh()

    def calltarget(self):
        '''
        Executes calltarget to generate a shape file for builtin target geometries.
        '''
            
        self.write()

        subprocess.call(os.path.join(ddscat_path, 'calltarget'), cwd=self.folder)



    
    
    
